###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        30/Mar/2019  15:46:49
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\modbus\modbus_port\portCB.c
#    Command line =  
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\modbus\modbus_port\portCB.c
#        -lcN
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\List\
#        -lb
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\List\
#        -o
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\DFB_inc\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\..\Libraries\CMSIS\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\ascii\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\include\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\modbus_port\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\rtu\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\tcp\
#        -On -I "E:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\List\portCB.lst
#    Object file  =  
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\Obj\portCB.o
#
###############################################################################

F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\modbus\modbus_port\portCB.c
      1          #include <stdio.h>
      2          #include "mb.h"
      3          #include "mbutils.h"
      4          #include "command.h"
      5          
      6          extern eMBErrorCode  eWriteMBRegInput( USHORT * pucRegBuffer, USHORT usAddress, USHORT usNRegs);
      7          extern eMBErrorCode  eReadMBRegHolding( USHORT * pucRegBuffer, USHORT usAddress, USHORT usNRegs);
      8          
      9          
     10          
     11          #define REG_HOLDING_START 0x0001
     12          #define REG_HOLDING_NREGS CMD_MOBUS_HOLD_REG_LENGTH
     13          USHORT  usRegHoldingBuf[REG_HOLDING_NREGS] = 
     14          {
     15          0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
     16          0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
     17          0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
     18          0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
     19          0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
     20          0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
     21          0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
     22          
     23          };
     24          
     25          eMBErrorCode  eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs,
     26          eMBRegisterMode eMode )
     27          {
     28          
     29              eMBErrorCode eStatus = MB_ENOERR;
     30              USHORT iRegIndex;
     31              USHORT iRegData;
     32          
     33              if(pucRegBuffer == (void*)0)
     34                  return MB_EINVAL;
     35                  
     36              if( ( (USHORT)usAddress >= REG_HOLDING_START ) \
     37              && ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
     38              {
     39                  iRegIndex = ( USHORT )( usAddress - REG_HOLDING_START );
     40          
     41                  switch ( eMode )
     42                  {
     43                      case MB_REG_READ:
     44                      {
     45                          while( usNRegs > 0 )
     46                          {
     47                              iRegData = usRegHoldingBuf[iRegIndex];
     48                              *pucRegBuffer++ = ( UCHAR )( iRegData >> 8 );
     49                              *pucRegBuffer++ = ( UCHAR )( iRegData & 0xFF );
     50                              iRegIndex++;
     51                              usNRegs--;
     52                          }
     53          
     54                      }
     55                      break;
     56          
     57                      case MB_REG_WRITE:
     58                      {
     59                          while( usNRegs > 0 )
     60                          {
     61                              iRegData = *pucRegBuffer++ << 8;
     62                              iRegData |= *pucRegBuffer++;
     63                              usRegHoldingBuf[iRegIndex] = iRegData;
     64                              iRegIndex++;
     65                              usNRegs--;
     66                          }
     67                          eStatus = eReadMBRegHolding(cmd_lock_reg,CMD_LOCK_OFFSET,CMD_LOCK_LENGTH);
     68                          eStatus = eReadMBRegHolding(cmd_potentiometer_res,CMD_PO_RES_OFFSET,CMD_PO_RES_LENGTH);
     69                          eStatus = eReadMBRegHolding(cmd_pwrdn_dac,CMD_PWRDN_DAC_OFFSET,CMD_PWRDN_DAC_LENGTH);
     70                          eStatus = eReadMBRegHolding(cmd_vcc_en,CMD_VCC_EN_OFFSET,CMD_VCC_EN_LENGTH);
     71                          eStatus = eReadMBRegHolding(cmd_max7312_en,CMD_MAX7312_OFFSET,CMD_MAX7312_LENGTH);
     72                          eStatus = eReadMBRegHolding(cmd_cur_dac,CMD_CUR_DAC_OFFSET,CMD_CUR_DAC_LENGTH);
     73                          eStatus = eReadMBRegHolding(cmd_eep,CMD_EEP_OFFSET,CMD_EEP_LENGTH);
     74                      }
     75                      break;
     76                  }
     77              }
     78              else
     79              {
     80                  eStatus = MB_ENOREG;
     81              }
     82          
     83              return eStatus;
     84          }
     85          
     86          
     87          
     88          #define REG_INPUT_START 0x0001
     89          #define REG_INPUT_NREGS CMD_MOBUS_INPUT_REG_LENGTH
     90          USHORT  usRegInputBuf[CMD_MOBUS_INPUT_REG_LENGTH] = {0x2019,0x0330,};
     91          
     92          eMBErrorCode  eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
     93          {
     94              eMBErrorCode eStatus = MB_ENOERR;
     95              USHORT iRegIndex;
     96              USHORT iRegData;
     97              if(pucRegBuffer == (void*)0)
     98                  return MB_EINVAL;
     99              
    100              eStatus = eWriteMBRegInput(&cmd_adc_tout[0],CMD_TSAMP_OFFSET,CMD_TSAMP_LENGTH);
    101              eStatus = eWriteMBRegInput(&cmd_adc_iout[0],CMD_ISAMP_OFFSET,CMD_ISAMP_LENGTH);
    102              eStatus = eWriteMBRegInput(&cmd_adc_mout[0],CMD_MSAMP_OFFSET,CMD_MSAMP_LENGTH);
    103              eStatus = eWriteMBRegInput(&cmd_adc_vout[0],CMD_VSAMP_OFFSET,CMD_VSAMP_LENGTH);
    104              eStatus = eWriteMBRegInput(&cmd_rd_eep[0],CMD_EEP_RD_OFFSET,CMD_EEP_RD_LENGTH);
    105          
    106              if( ( (USHORT)usAddress >= REG_INPUT_START ) \
    107              && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) )
    108              {
    109                  iRegIndex = ( USHORT )( usAddress - REG_INPUT_START );
    110                  while( usNRegs > 0 )
    111                  {
    112                      iRegData = usRegInputBuf[iRegIndex];
    113                      *pucRegBuffer++ = ( UCHAR )( iRegData >> 8 );
    114                      *pucRegBuffer++ = ( UCHAR )( iRegData & 0xFF );
    115                      iRegIndex++;
    116                      usNRegs--;
    117                  }
    118              }
    119              else
    120              {
    121                  eStatus = MB_ENOREG;
    122              }
    123          
    124              return eStatus;
    125          }
    126          
    127          
    128          
    129          
    130          
    131          
    132          
    133          
    134          eMBErrorCode    eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress,
    135                                         USHORT usNCoils, eMBRegisterMode eMode )
    136          {
    137              return MB_ENOERR;
    138          
    139          }
    140          
    141          eMBErrorCode    eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress,
    142                                            USHORT usNDiscrete )
    143          {
    144             return MB_ENOERR;
    145          
    146          }
    147          
    148          
    149          eMBErrorCode  eWriteMBRegInput( USHORT * pucRegBuffer, USHORT usAddress, USHORT usNRegs)
    150          {
    151              eMBErrorCode eStatus = MB_ENOERR;
    152              USHORT iRegIndex;
    153          
    154              if(pucRegBuffer == (void*)0)
    155                  return MB_EINVAL;
    156          
    157              if( ( (USHORT)usAddress >= 0u ) \
    158              && ( usAddress + usNRegs <= REG_INPUT_NREGS ) )
    159              {
    160                  iRegIndex = usAddress;
    161                  __disable_irq();
    162                  while( usNRegs > 0 )
    163                  {
    164                      usRegInputBuf[iRegIndex] = *pucRegBuffer++;
    165                      iRegIndex++;
    166                      usNRegs--;
    167                  }
    168                  __enable_irq();
    169              }
    170              else
    171              {
    172                  eStatus = MB_ENOREG;
    173              }
    174              return eStatus;
    175          
    176          }
    177          eMBErrorCode  eReadMBRegHolding( USHORT * pucRegBuffer, USHORT usAddress, USHORT usNRegs)
    178          {
    179              eMBErrorCode eStatus = MB_ENOERR;
    180              USHORT iRegIndex;
    181              
    182              if(pucRegBuffer == (void*)0)
    183                  return MB_EINVAL;
    184          
    185          
    186              if( ( (USHORT)usAddress >= 0u ) \
    187              && ( usAddress + usNRegs <=  REG_HOLDING_NREGS ) )
    188              {
    189                  iRegIndex = usAddress;
    190                  __disable_irq();
    191                  while( usNRegs > 0 )
    192                  {
    193                      *pucRegBuffer++  = usRegHoldingBuf[iRegIndex];
    194                      iRegIndex++;
    195                      usNRegs--;
    196                  }
    197                  __enable_irq();
    198              }
    199              else
    200              {
    201                  eStatus = MB_ENOREG;
    202              }
    203              return eStatus;
    204          }
    205          
    206          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   eMBRegCoilsCB
       0   eMBRegDiscreteCB
      32   eMBRegHoldingCB
        32   -> eReadMBRegHolding
      32   eMBRegInputCB
        32   -> eWriteMBRegInput
       8   eReadMBRegHolding
      12   eWriteMBRegInput


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      10  eMBRegCoilsCB
       6  eMBRegDiscreteCB
     240  eMBRegHoldingCB
     156  eMBRegInputCB
      68  eReadMBRegHolding
      68  eWriteMBRegInput
     108  usRegHoldingBuf
     224  usRegInputBuf

 
 108 bytes in section .bss
 224 bytes in section .data
 604 bytes in section .text
 
 604 bytes of CODE memory
 332 bytes of DATA memory

Errors: none
Warnings: 2
