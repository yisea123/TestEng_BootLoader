###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        30/Mar/2019  15:46:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\DFB_src\command.c
#    Command line =  
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\DFB_src\command.c
#        -lcN
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\List\
#        -lb
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\List\
#        -o
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\DFB_inc\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\..\Libraries\CMSIS\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\ascii\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\include\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\modbus_port\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\rtu\
#        -I
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\..\modbus\tcp\
#        -On -I "E:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\List\command.lst
#    Object file  =  
#        F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\dfb\Burn_in_2\Obj\command.o
#
###############################################################################

F:\FLT\GitHub\TestEng_FL0001A00\TestEng_FL0001A00\dfb\DFB_src\command.c
      1          /**
      2            ******************************************************************************
      3            * @file    command.c  burn in system
      4            * @author  h&h
      5            * @version 
      6            * @date    
      7            * @brief   command.c
      8            ******************************************************************************
      9            * 
     10            *
     11            */ 
     12          
     13          #include "include.h"
     14          #include "port.h"
     15          
     16          
     17          uint16_t cmd_lock_reg[CMD_LOCK_LENGTH];
     18          uint8_t  cmd_lock_st = TRUE;
     19          #define CMD_LOCK_ST cmd_lock_st
     20          
     21          void cmd_check_lock(void)
     22          {
     23              if((cmd_lock_reg[0] == 0xDEAD) && (cmd_lock_reg[1] == 0xBEEF))
     24                  cmd_lock_st = FALSE;
     25              else
     26                  cmd_lock_st = TRUE;
     27          }
     28          
     29          
     30          uint16_t cmd_potentiometer_res_old[CMD_PO_RES_LENGTH];
     31          uint16_t cmd_potentiometer_res[CMD_PO_RES_LENGTH];
     32          
     33          void cmd_write_potentiometer(void)
     34          {
     35              uint8_t ret;
     36          
     37              if(CMD_LOCK_ST == FALSE)
     38              {
     39                  if(cmd_potentiometer_res_old[0] != cmd_potentiometer_res[0])
     40                  {        
     41                      ret = MAX5478_write_potentiometer((uint8_t)cmd_potentiometer_res[0]);
     42                      cmd_potentiometer_res_old[0] = cmd_potentiometer_res[0];
     43                  }
     44                  else
     45                  {
     46          
     47                  }
     48              }
     49              else
     50              {
     51              
     52              }
     53          }
     54          
     55          uint16_t cmd_vcc_en_old[CMD_VCC_EN_LENGTH];
     56          uint16_t cmd_vcc_en[CMD_VCC_EN_LENGTH];
     57          void cmd_write_vcc_en(void)
     58          {
     59              uint8_t ret;
     60          
     61              if(CMD_LOCK_ST == FALSE)
     62              {
     63                  if(cmd_vcc_en[0] != cmd_vcc_en_old[0])
     64                  {
     65                      if(0xABCD == cmd_vcc_en[0])
     66                      {
     67                          Enable_sw_vs1();
     68                          Delay_ms(10);
     69                      }
     70                      else
     71                      {
     72                          Disable_sw_vs1();
     73                      }
     74                      cmd_vcc_en_old[0] = cmd_vcc_en[0];
     75                  }
     76              }
     77              else
     78              {
     79              
     80              }
     81          }
     82          
     83          uint16_t cmd_max7312_en_old[CMD_MAX7312_LENGTH];
     84          uint16_t cmd_max7312_en[CMD_MAX7312_LENGTH];
     85          void cmd_write_switches(void)
     86          {
     87              uint8_t ret, i, res_port1, res_port2;
     88              uint16_t res=0;
     89          
     90              if(CMD_LOCK_ST == FALSE)
     91              {
     92                  for(i=0; i<2; i++)
     93                  {
     94                      if(cmd_max7312_en_old[i] != cmd_max7312_en[i])
     95                      {
     96          
     97                          Max7312_Set_All_Port_Output(0);
     98                          Max7312_Set_All_Port_Output(1);
     99          
    100                          res = cmd_max7312_en[i];
    101                          res_port1 = res & 0x00FF;
    102                          res_port2 = (res & 0xFF00)>>8;
    103                          ret = Max7312_Set_Port1_HiLo(i, res_port1);
    104                          ret = Max7312_Set_Port2_HiLo(i, res_port2);
    105                          cmd_max7312_en_old[i] = cmd_max7312_en[i];
    106                      }
    107                      else
    108                      {
    109                          /*do nothing*/
    110                      }
    111                  }
    112              }
    113              else
    114              {
    115                  /*do nothing*/
    116              }   
    117          }
    118          
    119          #define LTC2620_CHIP_NUM 4
    120          #define LTC2620_CHIP_CHN 8
    121          
    122          uint8_t  cmd_cur_dac_cs[LTC2620_CHIP_NUM]=
    123          {
    124              LTC2620_CHIP_ID_1,
    125              LTC2620_CHIP_ID_2,
    126              LTC2620_CHIP_ID_3,
    127              LTC2620_CHIP_ID_4,
    128          };
    129          
    130          uint16_t cmd_pwrdn_dac_old[CMD_PWRDN_DAC_LENGTH];
    131          uint16_t cmd_pwrdn_dac[CMD_PWRDN_DAC_LENGTH];
    132          uint32_t cmd_pwrdn_current_st;
    133          uint32_t cmd_pwrdn_update_ch_st;
    134          
    135          #define cmd_is_chp_pwrdn_updated(i) ((cmd_pwrdn_update_ch_st & ((uint32_t)0xFF)<<(i*LTC2620_CHIP_CHN))?1u:0u)
    136          #define cmd_is_chn_pwrdn_updated(i) ((cmd_pwrdn_update_ch_st & (1u<<i))?1u:0u)
    137          #define cmd_is_ch_pwrdn(i) ((cmd_pwrdn_current_st & (1u<<i))?1u:0u)
    138          
    139          
    140          #define LTC2620_MAX_VALUE 0xFFFFu
    141          #define LTC2620_MIN_VALUE 0x0000u
    142          uint16_t cmd_cur_dac_old[CMD_CUR_DAC_LENGTH];
    143          uint16_t cmd_cur_dac[CMD_CUR_DAC_LENGTH];
    144          uint32_t cmd_cur_dac_upd_ch_st;
    145          
    146          #define cmd_is_chp_value_updated(i) ((cmd_cur_dac_upd_ch_st & ((uint32_t)0xFF)<<(i*LTC2620_CHIP_CHN))?1u:0u)
    147          #define cmd_is_chn_value_updated(i) ((cmd_cur_dac_upd_ch_st & (1u<<i))?1u:0u)
    148          
    149          
    150          void cmd_powerdown_cur_dac(void)
    151          {
    152              uint8_t i, j;
    153              uint8_t ch;
    154              uint8_t ret;
    155          
    156              if(CMD_LOCK_ST == TRUE)
    157                  return;
    158          
    159              if( (cmd_pwrdn_dac_old[0] != cmd_pwrdn_dac[0]) || 
    160                  (cmd_pwrdn_dac_old[1] != cmd_pwrdn_dac[1]) )
    161              {
    162                  cmd_pwrdn_dac_old[0] = cmd_pwrdn_dac[0];
    163                  cmd_pwrdn_dac_old[1] = cmd_pwrdn_dac[1];
    164                  cmd_pwrdn_update_ch_st = cmd_pwrdn_current_st;
    165                  cmd_pwrdn_current_st = ((uint32_t)cmd_pwrdn_dac_old[1]<<16) | (uint32_t)cmd_pwrdn_dac_old[0];
    166                  cmd_pwrdn_update_ch_st ^= cmd_pwrdn_current_st;
    167              }
    168              else
    169              {
    170                  cmd_pwrdn_update_ch_st = 0;
    171              }
    172          
    173              for(i=0; i<LTC2620_CHIP_NUM; i++)
    174              {
    175                  if(cmd_is_chp_pwrdn_updated(i))
    176                  {
    177                      DRV_SPI_CS_LTC2620(LTC2620_CHIP_NONE);
    178                      Delay_us(1);
    179                      DRV_SPI_CS_LTC2620(cmd_cur_dac_cs[i]);
    180                      Delay_us(5);
    181          
    182                      for(j=0; j<LTC2620_CHIP_CHN; j++)
    183                      {
    184                          ch = i*LTC2620_CHIP_CHN +j;
    185                          if(cmd_is_chn_pwrdn_updated(ch))
    186                          {
    187                              if(cmd_is_ch_pwrdn(ch))
    188                              {
    189                                  ret = LTC2620_Powerdown_n(j);
    190                              }
    191                              else
    192                              {
    193                                  ret = LTC2620_Write_n_Updata_n(j,cmd_cur_dac_old[ch]);
    194                              }
    195                          }
    196                          else
    197                          {
    198                          }
    199                      }
    200                      
    201                  }
    202              }
    203              DRV_SPI_CS_LTC2620(LTC2620_CHIP_NONE);
    204          }
    205          
    206          
    207          void cmd_write_cur_dac(void)
    208          {
    209              uint8_t i, j;
    210              uint8_t ch;
    211              uint8_t ret;
    212          
    213              if(CMD_LOCK_ST == TRUE)
    214                  return;
    215              
    216              cmd_cur_dac_upd_ch_st = 0;
    217              
    218              for(i=0; i<LTC2620_CHIP_NUM; i++)
    219              {
    220                  for(j=0; j<LTC2620_CHIP_CHN; j++)
    221                  {
    222                      ch = i*LTC2620_CHIP_CHN +j;
    223                      if(cmd_cur_dac_old[ch] != cmd_cur_dac[ch])
    224                      {
    225                          cmd_cur_dac_old[ch] = cmd_cur_dac[ch];
    226                          if(cmd_cur_dac_old[ch] > LTC2620_MAX_VALUE)
    227                              cmd_cur_dac_old[ch] = LTC2620_MAX_VALUE;
    228                          if(cmd_cur_dac_old[ch] < LTC2620_MIN_VALUE)
    229                              cmd_cur_dac_old[ch] = LTC2620_MIN_VALUE;
    230          
    231                          cmd_cur_dac_upd_ch_st |= 1u<<ch;
    232                      }
    233                      else
    234                      {
    235                      }
    236                  }
    237              }
    238          
    239              for(i=0; i<LTC2620_CHIP_NUM; i++)
    240              {
    241                  if(cmd_is_chp_value_updated(i))
    242                  {
    243                      for(j=0; j<LTC2620_CHIP_CHN; j++)
    244                      {
    245                          DRV_SPI_CS_LTC2620(LTC2620_CHIP_NONE);
    246                          Delay_us(1);
    247                          DRV_SPI_CS_LTC2620(cmd_cur_dac_cs[i]);
    248                          Delay_us(5);
    249          
    250                          ch = i*LTC2620_CHIP_CHN + j;
    251                          if(cmd_is_chn_value_updated(ch) && !cmd_is_ch_pwrdn(ch) )
    252                          {
    253                              ret = LTC2620_Write_n_Updata_n(j,cmd_cur_dac_old[ch]);
    254                              Delay_ms(1);
    255                          }
    256                          else
    257                          {
    258                          }
    259                      }
    260                  }
    261              }
    262              DRV_SPI_CS_LTC2620(LTC2620_CHIP_NONE);
    263          }
    264          
    265          uint16_t cmd_eep_old[CMD_EEP_LENGTH];
    266          uint16_t cmd_eep[CMD_EEP_LENGTH];
    267          uint16_t cmd_rd_eep[CMD_EEP_DATA_LENGTH];
    268          
    269          uint32_t cmd_eep_addr;
    270          uint32_t cmd_eep_lenth;
    271          uint32_t  cmd_eep_rd_wr_st;
    272          
    273          #define  CMD_OPERATION_NEW 1
    274          #define  CMD_OPERATION_NUL 0
    275          
    276          void cmd_rd_wr_eep(void)
    277          {
    278              uint8_t i;
    279              uint8_t  cmd_eep_operation_st = CMD_OPERATION_NUL;
    280          
    281              if(CMD_LOCK_ST == FALSE)
    282              {
    283                  for(i=0; i<CMD_EEP_LENGTH; i++)
    284                  {
    285                      if(cmd_eep[i] != cmd_eep_old[i])
    286                      {
    287                          cmd_eep_operation_st = CMD_OPERATION_NEW;
    288                          break;
    289                      }
    290                  }
    291          
    292                  if(CMD_OPERATION_NEW == cmd_eep_operation_st)
    293                  {
    294                      cmd_eep_addr = ((uint32_t)cmd_eep[1]<<16) | cmd_eep[0];
    295                      cmd_eep_lenth = ((uint32_t)cmd_eep[3]<<16) | cmd_eep[2];
    296                      cmd_eep_rd_wr_st = ((uint32_t)cmd_eep[5]<<16) | cmd_eep[4];
    297                      if(cmd_eep_lenth > CMD_EEP_DATA_LENGTH * 2)
    298                          cmd_eep_lenth = CMD_EEP_DATA_LENGTH * 2;
    299          
    300                      /*write operation*/
    301                      if(cmd_eep_rd_wr_st == 0xCC98CC98)
    302                      {
    303                          AT24HC02C_wr_n_bytes(0, cmd_eep_addr, cmd_eep_lenth, (uint8_t*)&cmd_eep[CMD_EEP_DATA_OFFSET]);
    304                      }
    305                      else if(cmd_eep_rd_wr_st == 0xAA55AA55)/*read operation*/
    306                      {
    307                          AT24HC02C_rd_n_bytes(0, cmd_eep_addr, cmd_eep_lenth, (uint8_t*)&cmd_rd_eep[0]);
    308                      }
    309                      else
    310                      {
    311                          for(i=0; i<CMD_EEP_DATA_LENGTH; i++)
    312                          {
    313                              cmd_rd_eep[i] = 0;
    314                          }
    315          
    316                      }
    317                      for(i=0; i<CMD_EEP_LENGTH; i++)
    318                      {
    319                          cmd_eep_old[i] = cmd_eep[i];
    320                      }
    321                      
    322                      cmd_eep_operation_st = CMD_OPERATION_NUL;
    323                  }
    324          
    325              }
    326              else
    327              {
    328              
    329              }
    330          
    331          
    332          }
    333          
    334          
    335          uint16_t cmd_adc_tout[CMD_TSAMP_LENGTH];
    336          void cmd_read_thmo(void)
    337          {
    338              uint8_t i;
    339              uint8_t ret;
    340          
    341              if(CMD_LOCK_ST == FALSE)
    342              {
    343                  for(i=0; i<CMD_TSAMP_LENGTH; i++)
    344                  {
    345                      ret = AD7949_read_THERMO_ch(i, &cmd_adc_tout[i]);
    346                  }
    347              }
    348              else
    349              {
    350              
    351              }
    352          }
    353          
    354          
    355          uint16_t cmd_adc_iout[CMD_ISAMP_LENGTH];
    356          void cmd_read_iout(void)
    357          {
    358              uint8_t i;
    359              uint8_t ret;
    360          
    361              if(CMD_LOCK_ST == FALSE)
    362              {
    363                  for(i=0; i<CMD_ISAMP_LENGTH; i++)
    364                  {
    365                      ret = AD7949_read_ISAMP_ch(i, &cmd_adc_iout[i]);
    366                  }
    367              }
    368              else
    369              {
    370              
    371              }
    372          }
    373          
    374          
    375          uint16_t cmd_adc_mout[CMD_MSAMP_LENGTH];
    376          void cmd_read_mout(void)
    377          {
    378              uint8_t i;
    379              uint8_t ret;
    380          
    381              if(CMD_LOCK_ST == FALSE)
    382              {
    383                  for(i=0; i<CMD_MSAMP_LENGTH; i++)
    384                  {
    385                      ret = AD7949_read_MPD_ch(i, &cmd_adc_mout[i]);
    386                  }
    387              }
    388              else
    389              {
    390              
    391              }
    392          }
    393          
    394          uint16_t cmd_adc_vout[CMD_VSAMP_LENGTH];
    395          void cmd_read_vout(void)
    396          {
    397              uint8_t i;
    398              uint8_t ret;
    399          
    400              if(CMD_LOCK_ST == FALSE)
    401              {
    402                  for(i=0; i<CMD_VSAMP_LENGTH; i++)
    403                  {
    404                      ret = AD7949_read_VSAMP_ch(i, &cmd_adc_vout[i]);
    405                  }
    406              }
    407              else
    408              {
    409              
    410              }
    411          }
    412          
    413          
    414          void cmd_stage_fast_proc(void)
    415          {
    416              cmd_check_lock();
    417              cmd_write_potentiometer();
    418              cmd_write_vcc_en();
    419              cmd_write_switches();
    420              cmd_rd_wr_eep();
    421              cmd_powerdown_cur_dac();
    422              cmd_write_cur_dac();
    423              cmd_read_thmo();
    424              cmd_read_iout();
    425              cmd_read_mout();
    426              cmd_read_vout();
    427          
    428          }
    429          void cmd_stage_slow_proc(void)
    430          {
    431              AD7949_read_all_data();
    432          }
    433          
    434          #if 0
    435          uint16_t cmd_stage1_vol_dac_old[CMD_STAGE1_VOL_DAC_LENGTH];
    436          uint16_t cmd_stage1_vol_dac[CMD_STAGE1_VOL_DAC_LENGTH];
    437          #define  CMD_STAGE1_VOL_DAC_OFF 8
    438          void cmd_stage1_write_vol_dac(void)
    439          {
    440              uint8_t i;
    441              uint8_t ret;
    442          
    443              if(CMD_LOCK_ST == FALSE)
    444              {
    445                  for(i=0; i<CMD_STAGE1_VOL_DAC_LENGTH;i++)
    446                  {
    447                      if(cmd_stage1_vol_dac[i] > LTC2620_MAX_VALUE)
    448                          cmd_stage1_vol_dac[i] = LTC2620_MAX_VALUE;
    449                      if(cmd_stage1_vol_dac[i] < LTC2620_MIN_VALUE)
    450                          cmd_stage1_vol_dac[i] = LTC2620_MIN_VALUE;
    451          
    452                      if(cmd_stage1_vol_dac_old[i] != cmd_stage1_vol_dac[i])
    453                      {
    454                          ret = LTC2620_Write_n_Updata_n( i+CMD_STAGE1_VOL_DAC_OFF,cmd_stage1_vol_dac[i]);
    455                          cmd_stage1_vol_dac_old[i] = cmd_stage1_vol_dac[i];
    456                      }
    457                      else
    458                      {
    459          
    460                      }       
    461                  }
    462              }
    463              else
    464              {
    465              
    466              }   
    467          }
    468          
    469          uint16_t cmd_stage2_pn6v_old[CMD_STAGE2_PV6V_LENGTH];
    470          uint16_t cmd_stage2_pn6v[CMD_STAGE2_PV6V_LENGTH];
    471          
    472          void cmd_stage2_write_pn6v(void)
    473          {
    474              uint8_t ret;
    475          
    476              if(CMD_LOCK_ST == FALSE)
    477              {
    478                  if(cmd_stage2_pn6v_old[0] != cmd_stage2_pn6v[0])
    479                  {        
    480                      ret = Max7312_Set_Port1_HiLo(1, cmd_stage2_pn6v[0]);
    481                      cmd_stage2_pn6v_old[0] = cmd_stage2_pn6v[0];
    482                  }
    483                  else
    484                  {
    485          
    486                  }       
    487              }
    488              else
    489              {
    490              
    491              }   
    492          }
    493          
    494          uint16_t cmd_stage3_vout_old[CMD_STAGE3_VOUT_LENGTH];
    495          uint16_t cmd_stage3_vout[CMD_STAGE3_VOUT_LENGTH];
    496          
    497          void cmd_stage3_write_vout(void)
    498          {
    499              uint8_t ret;
    500          
    501              if(CMD_LOCK_ST == FALSE)
    502              {
    503                  if(cmd_stage3_vout_old[0] != cmd_stage3_vout[0])
    504                  {        
    505                      ret = Max7312_Set_Port1_HiLo(0, cmd_stage3_vout[0]);
    506                      cmd_stage3_vout_old[0] = cmd_stage3_vout[0];
    507                  }
    508                  else
    509                  {
    510          
    511                  }       
    512              }
    513              else
    514              {
    515              
    516              }   
    517          }
    518          
    519          uint16_t cmd_stage3_iout_old[CMD_STAGE3_IOUT_LENGTH];
    520          uint16_t cmd_stage3_iout[CMD_STAGE3_IOUT_LENGTH];
    521          
    522          void cmd_stage3_write_iout(void)
    523          {
    524              uint8_t ret;
    525          
    526              if(CMD_LOCK_ST == FALSE)
    527              {
    528                  if(cmd_stage3_iout_old[0] != cmd_stage3_iout[0])
    529                  {        
    530                      ret = Max7312_Set_Port2_HiLo(0, cmd_stage3_iout[0]);
    531                      cmd_stage3_iout_old[0] = cmd_stage3_iout[0];
    532                  }
    533                  else
    534                  {
    535          
    536                  }       
    537              }
    538              else
    539              {
    540              
    541              }   
    542          }
    543          
    544          #endif
    545          /******************* (C) COPYRIGHT 2018 *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   cmd_check_lock
      24   cmd_powerdown_cur_dac
        24   -> Delay_us
        24   -> LTC2620_Powerdown_n
        24   -> LTC2620_Write_n_Updata_n
        24   -> Set_spi_cs_n
      16   cmd_rd_wr_eep
        16   -> AT24HC02C_rd_n_bytes
        16   -> AT24HC02C_wr_n_bytes
      16   cmd_read_iout
        16   -> AD7949_read_ISAMP_ch
      16   cmd_read_mout
        16   -> AD7949_read_MPD_ch
      16   cmd_read_thmo
        16   -> AD7949_read_THERMO_ch
      16   cmd_read_vout
        16   -> AD7949_read_VSAMP_ch
       8   cmd_stage_fast_proc
         8   -> cmd_check_lock
         8   -> cmd_powerdown_cur_dac
         8   -> cmd_rd_wr_eep
         8   -> cmd_read_iout
         8   -> cmd_read_mout
         8   -> cmd_read_thmo
         8   -> cmd_read_vout
         8   -> cmd_write_cur_dac
         8   -> cmd_write_potentiometer
         8   -> cmd_write_switches
         8   -> cmd_write_vcc_en
       8   cmd_stage_slow_proc
         8   -> AD7949_read_all_data
      24   cmd_write_cur_dac
        24   -> Delay_ms
        24   -> Delay_us
        24   -> LTC2620_Write_n_Updata_n
        24   -> Set_spi_cs_n
       8   cmd_write_potentiometer
         8   -> MAX5478_write_potentiometer
      24   cmd_write_switches
        24   -> Max7312_Set_All_Port_Output
        24   -> Max7312_Set_Port1_HiLo
        24   -> Max7312_Set_Port2_HiLo
       8   cmd_write_vcc_en
         8   -> Delay_ms
         8   -> Disable_sw_vs1
         8   -> Enable_sw_vs1


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_27
       4  ??DataTable10_28
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      64  cmd_adc_iout
      64  cmd_adc_mout
       4  cmd_adc_tout
      64  cmd_adc_vout
      48  cmd_check_lock
      64  cmd_cur_dac
       4  cmd_cur_dac_cs
      64  cmd_cur_dac_old
       4  cmd_cur_dac_upd_ch_st
      28  cmd_eep
       4  cmd_eep_addr
       4  cmd_eep_lenth
      28  cmd_eep_old
       4  cmd_eep_rd_wr_st
       4  cmd_lock_reg
       1  cmd_lock_st
       4  cmd_max7312_en
       4  cmd_max7312_en_old
       2  cmd_potentiometer_res
       2  cmd_potentiometer_res_old
     282  cmd_powerdown_cur_dac
       4  cmd_pwrdn_current_st
       4  cmd_pwrdn_dac
       4  cmd_pwrdn_dac_old
       4  cmd_pwrdn_update_ch_st
      16  cmd_rd_eep
     244  cmd_rd_wr_eep
      46  cmd_read_iout
      46  cmd_read_mout
      46  cmd_read_thmo
      46  cmd_read_vout
      48  cmd_stage_fast_proc
       8  cmd_stage_slow_proc
       2  cmd_vcc_en
       2  cmd_vcc_en_old
     252  cmd_write_cur_dac
      56  cmd_write_potentiometer
     146  cmd_write_switches
      72  cmd_write_vcc_en

 
   448 bytes in section .bss
     5 bytes in section .data
 1 456 bytes in section .text
 
 1 456 bytes of CODE memory
   453 bytes of DATA memory

Errors: none
Warnings: 11
